#!/usr/bin/env python3
import pandas as pd
import joblib
import numpy as np
import subprocess
from pathlib import Path

# 尝试导入 tflite-runtime，否则退回到 tensorflow
try:
    from tflite_runtime.interpreter import Interpreter
except ImportError:
    import tensorflow as tf
    Interpreter = tf.lite.Interpreter

# -------- 配置 --------
CSV_FILE        = "rescheduling_dataset_large_10000.csv"
VECT_FILE       = "vectorizer_augmented.joblib"
TFLITE_FILE     = "rescheduler_int8.tflite"

OUT_CAND_H      = Path("candidates.h")
OUT_FEAT_H      = Path("cand_feat.h")
OUT_INIT_H      = Path("initial_instr.h")

TMP_DIR         = Path("cand_temp")
N_CAND          = 10
N_INST          = 100

RISCV_AS        = "riscv64-unknown-elf-as"
RISCV_OBJCOPY   = "riscv64-unknown-elf-objcopy"

# 汇编模版
ASM_TPL = {
    'add':   "  add   x{d},x{s0},x{s1}",
    'sub':   "  sub   x{d},x{s0},x{s1}",
    'addi':  "  addi  x{d},x0,{imm}",
    'lw':    "  lw    x{d},0(x2)",
    'sw':    "  sw    x{s0},0(x2)",
}

def make_asm(seq):
    """把一个 instr name 列表生成 RISC-V asm 文本。"""
    lines = [
        "\t.section .text",
        "\t.global _start",
        "_start:",
    ]
    for inst in seq:
        op = inst.split("_")[0]
        if op in ("add", "sub"):
            _, rd, rs0, rs1 = inst.split("_")
            lines.append(ASM_TPL[op].format(d=rd[1:], s0=rs0[1:], s1=rs1[1:]))
        elif op == "addi":
            _, rd, _, imm = inst.split("_")
            lines.append(ASM_TPL[op].format(d=rd[1:], imm=imm))
        elif op == "lw":
            _, rd, _ = inst.split("_")
            lines.append(ASM_TPL[op].format(d=rd[1:]))
        elif op == "sw":
            _, rs0, _ = inst.split("_")
            lines.append(ASM_TPL[op].format(s0=rs0[1:]))
        else:
            # 如果遇到不支持的，直接生成 nop，占位
            lines.append("  nop")
    lines.append("loop: j loop")
    return "\n".join(lines)

def assemble_and_pad(s_path: Path, bin_path: Path):
    """汇编 s_path -> o -> bin，然后截断/填充到 N_INST*4 字节"""
    o_path = s_path.with_suffix(".o")
    # 1) 汇编
    subprocess.run([RISCV_AS, "-march=rv32im", "-mabi=ilp32",
                    "-o", str(o_path), str(s_path)], check=True)
    # 2) 提取裸二进制 text 段
    subprocess.run([RISCV_OBJCOPY, "-O", "binary",
                    "--only-section", ".text",
                    str(o_path), str(bin_path)], check=True)
    data = bin_path.read_bytes()[: N_INST*4]
    # 3) pad
    nop = (0x00000013).to_bytes(4, "little")
    data = data + nop * ((N_INST*4 - len(data) + 3)//4)
    return data[: N_INST*4]

def main():
    TMP_DIR.mkdir(exist_ok=True)

    # 1) 读 CSV，取所有 sequence
    df = pd.read_csv(CSV_FILE)
    df['seq_list'] = df['sequence'].apply(eval)

    # 2) 生成 initial_instr.h —— 取第 1 条原始顺序
    init_seq = df.loc[0, 'seq_list']
    init_s   = TMP_DIR/"initial.s"
    init_b   = TMP_DIR/"initial.bin"
    init_s.write_text(make_asm(init_seq))
    init_bytes = assemble_and_pad(init_s, init_b)

    # 写 initial_instr.h
    with OUT_INIT_H.open("w") as f:
        f.write("// Auto-generated by gen_candf.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define INIT_COUNT {N_INST}\n\n")
        f.write("static const uint32_t initial_instr[INIT_COUNT] = {\n")
        for i in range(N_INST):
            w = int.from_bytes(init_bytes[i*4:(i+1)*4], "little")
            f.write(f"  0x{w:08X},\n")
        f.write("};\n")
    print("Wrote initial_instr.h")

    # 3) 随机抽样 N_CAND 条做 candidates
    samples = df['seq_list'].sample(N_CAND, random_state=123).tolist()
    bins = []
    for i, seq in enumerate(samples):
        s_file = TMP_DIR/f"cand{i}.s"
        b_file = TMP_DIR/f"cand{i}.bin"
        s_file.write_text(make_asm(seq))
        bins.append(assemble_and_pad(s_file, b_file))

    # 写 candidates.h
    with OUT_CAND_H.open("w") as f:
        f.write("// Auto-generated by gen_candf.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define N_CAND {N_CAND}\n")
        f.write(f"#define N_INST {N_INST}\n\n")
        f.write("static const uint32_t cand_seq[N_CAND][N_INST] = {\n")
        for data in bins:
            words = [f"0x{int.from_bytes(data[j*4:(j+1)*4],'little'):08X}"
                     for j in range(N_INST)]
            f.write("  { " + ", ".join(words) + " },\n")
        f.write("};\n")
    print("Wrote candidates.h")

    # 4) 生成 cand_feat.h
    vectorizer = joblib.load(VECT_FILE)
    FEATURE_DIM = len(vectorizer.get_feature_names_out())

    # 4.1) 拿 quant 参数
    interp = Interpreter(model_path=TFLITE_FILE)
    interp.allocate_tensors()
    inp_det = interp.get_input_details()[0]
    scale, zp = inp_det['quantization']

    # 4.2) 文本 -> ngram -> 浮点 -> 量化 int8
    lines = [" ".join(seq) for seq in samples]
    X = vectorizer.transform(lines).toarray().astype(np.float32)
    Xq = np.clip(np.round(X/scale + zp), -128, 127).astype(np.int8)

    # 写 cand_feat.h
    with OUT_FEAT_H.open("w") as f:
        f.write("// Auto-generated by gen_candf.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define N_CAND      {N_CAND}\n")
        f.write(f"#define FEATURE_DIM {FEATURE_DIM}\n\n")
        f.write("static const int8_t cand_feat[N_CAND][FEATURE_DIM] = {\n")
        for row in Xq:
            f.write("  { " + ", ".join(str(int(v)) for v in row) + " },\n")
        f.write("};\n")
    print("Wrote cand_feat.h")

if __name__ == "__main__":
    main()
