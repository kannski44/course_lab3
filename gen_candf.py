#!/usr/bin/env python3
import pandas as pd
import joblib
import numpy as np
import subprocess
from pathlib import Path

# -------- 配置 --------
CSV_FILE      = "rescheduling_dataset_large_10000.csv"
VECT_FILE     = "vectorizer_augmented.joblib"
OUT_FEAT_H    = Path("cand_feat.h")
OUT_CAND_H    = Path("candidates.h")
TMP_DIR       = Path("cand_temp")
N_CAND        = 10
N_INST        = 150
RISCV_AS      = "riscv64-unknown-elf-as"
RISCV_OBJCOPY = "riscv64-unknown-elf-objcopy"

# 指令名 -> 真实汇编模板
ASM_TPL = {
    'add':   "  add x{d},x{s0},x{s1}",
    'sub':   "  sub x{d},x{s0},x{s1}",
    'addi':  "  addi x{d},x0,{imm}",
    'lw':    "  lw x{d},{off}(x{s0})",
    'sw':    "  sw x{s0},{off}(x{d})",
}

def make_asm(seq, idx):
    """
    生成 cand_temp/cand{idx}.s
    只用算数、立即数、load/store，不用 branch/jal
    """
    lines = ["\t.section .text",
             "\t.global _start",
             "_start:"]
    # 假设 x2 固定指向数据段 base，off 全用 0
    for inst in seq:
        # inst 格式：add_r1_r2_r3 / sub_r4_r5_r6 / addi_r14_r0_5 / lw_r11_mem / sw_r22_mem
        parts = inst.split("_")
        op = parts[0]
        if op in ("add","sub"):
            _, rd, rs0, rs1 = parts
            lines.append( ASM_TPL[op].format(d=rd[1:], s0=rs0[1:], s1=rs1[1:]) )
        elif op=="addi":
            _, rd, _, imm = parts
            lines.append( ASM_TPL[op].format(d=rd[1:], imm=imm) )
        elif op=="lw":
            _, rd, _ = parts
            lines.append( ASM_TPL[op].format(d=rd[1:], s0=2, off=0) )
        elif op=="sw":
            _, rs0, _ = parts
            # store rs0 into [x2+0]
            lines.append( ASM_TPL[op].format(d=0, s0=rs0[1:], off=0) )
        else:
            # 跳过不支持的
            continue
    # 一个无限循环，防止 fallthrough
    lines.append("loop: j loop")
    return "\n".join(lines)

def assemble_and_extract(idx):
    """ 汇编 cand{idx}.s -> cand{idx}.o -> cand{idx}.bin """
    s_path = TMP_DIR/f"cand{idx}.s"
    o_path = TMP_DIR/f"cand{idx}.o"
    b_path = TMP_DIR/f"cand{idx}.bin"
    # 汇编
    subprocess.run([RISCV_AS, "-march=rv32im", "-mabi=ilp32",
                    "-o", str(o_path), str(s_path)], check=True)
    # 提取裸二进制 text 段
    subprocess.run([RISCV_OBJCOPY,
                    "-O", "binary",
                    "--only-section", ".text",
                    str(o_path), str(b_path)], check=True)
    data = b_path.read_bytes()
    # 填充/截断到 N_INST * 4 字节
    data = data[:N_INST*4].ljust(N_INST*4, b'\x00')
    return data

def main():
    # 准备临时目录
    TMP_DIR.mkdir(exist_ok=True)

    # 1) 从 CSV 随机抽 N_CAND 条
    df = pd.read_csv(CSV_FILE)
    df['seq_list'] = df['sequence'].apply(eval)
    samples = df['seq_list'].sample(N_CAND, random_state=123).tolist()

    # 2) 生成并汇编
    bins = []
    for i, seq in enumerate(samples):
        s = make_asm(seq, i)
        p = TMP_DIR/f"cand{i}.s"
        p.write_text(s)
        data = assemble_and_extract(i)
        bins.append(data)

    # 3) 写 candidates.h
    with OUT_CAND_H.open("w") as f:
        f.write("// Auto-generated by gen_candidates_and_feat.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define N_CAND {N_CAND}\n")
        f.write(f"#define N_INST {N_INST}\n\n")
        f.write("static const uint32_t cand_seq[N_CAND][N_INST] = {\n")
        for data in bins:
            # little endian 每 4 字节转成 uint32
            words = [f"0x{int.from_bytes(data[j*4:(j+1)*4],'little'):08X}"
                     for j in range(N_INST)]
            f.write("  { " + ", ".join(words) + " },\n")
        f.write("};\n")

    # 4) 生成 cand_feat.h 同之前
    # 4.a) 文本特征
    lines = [" ".join(seq) for seq in samples]
    vectorizer = joblib.load(VECT_FILE)
    FEATURE_DIM = len(vectorizer.get_feature_names_out())
    X = vectorizer.transform(lines).toarray().astype(np.float32)
    # 4.b) 量化
    def quantize(arr):
        ai = np.rint(arr).astype(np.int32)
        ai = np.clip(ai, -128, 127)
        return ai.astype(np.int8)
    Xq = quantize(X)
    # 4.c) 写 cand_feat.h
    with OUT_FEAT_H.open("w") as f:
        f.write("// Auto-generated by gen_candidates_and_feat.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define N_CAND {N_CAND}\n")
        f.write(f"#define FEATURE_DIM {FEATURE_DIM}\n\n")
        f.write("static const int8_t cand_feat[N_CAND][FEATURE_DIM] = {\n")
        for row in Xq:
            vals = ", ".join(str(int(v)) for v in row)
            f.write(f"  {{ {vals} }},\n")
        f.write("};\n")

    print("Generated:", OUT_CAND_H, OUT_FEAT_H)

if __name__=="__main__":
    main()
