#!/usr/bin/env python3
import pandas as pd
import joblib
import numpy as np
import subprocess
from pathlib import Path

# 尝试导入 tflite-runtime，否则退回到 tensorflow
try:
    from tflite_runtime.interpreter import Interpreter
except ImportError:
    import tensorflow as tf
    Interpreter = tf.lite.Interpreter

# -------- 配置 --------
#CSV_FILE        = "rescheduling_dataset_large_10000.csv"
CSV_FILE        = "rescheduling_dataset_150.csv"
VECT_FILE       = "vectorizer_augmented.joblib"
TFLITE_FILE     = "rescheduler_int8.tflite"
OUT_FEAT_H      = Path("cand_feat.h")
OUT_CAND_H      = Path("candidates.h")
TMP_DIR         = Path("cand_temp")
N_CAND          = 10
N_INST          = 150
RISCV_AS        = "riscv64-unknown-elf-as"
RISCV_OBJCOPY   = "riscv64-unknown-elf-objcopy"

ASM_TPL = {
    'add':   "  add   x{d}, x{s0}, x{s1}",
    'sub':   "  sub   x{d}, x{s0}, x{s1}",
    'addi':  "  addi  x{d}, x0, {imm}",
    'lw':    "  lw    x{d}, 0(x2)",
    'sw':    "  sw    x{s0}, 0(x2)",
}

def make_asm(seq, idx):
    lines = [
        "\t.section .text",
        "\t.global _start",
        "_start:"
    ]
    for inst in seq:
        op = inst.split("_")[0]
        if op in ("add", "sub"):
            _, rd, rs0, rs1 = inst.split("_")
            lines.append(ASM_TPL[op].format(d=rd[1:], s0=rs0[1:], s1=rs1[1:]))
        elif op=="addi":
            _, rd, _, imm = inst.split("_")
            lines.append(ASM_TPL[op].format(d=rd[1:], imm=imm))
        elif op=="lw":
            _, rd, _ = inst.split("_")
            lines.append(ASM_TPL[op].format(d=rd[1:]))
        elif op=="sw":
            _, rs0, _ = inst.split("_")
            lines.append(ASM_TPL[op].format(s0=rs0[1:]))
    lines.append("loop: j loop")
    return "\n".join(lines)

def assemble_and_extract(idx):
    s_path = TMP_DIR/f"cand{idx}.s"
    o_path = TMP_DIR/f"cand{idx}.o"
    b_path = TMP_DIR/f"cand{idx}.bin"
    subprocess.run([RISCV_AS, "-march=rv32im", "-mabi=ilp32",
                    "-o", str(o_path), str(s_path)], check=True)
    subprocess.run([RISCV_OBJCOPY,
                    "-O", "binary",
                    "--only-section", ".text",
                    str(o_path), str(b_path)], check=True)
    data = b_path.read_bytes()
    return data[:N_INST*4].ljust(N_INST*4, b'\x00')

def main():
    TMP_DIR.mkdir(exist_ok=True)

    # 1) 随机抽样
    df = pd.read_csv(CSV_FILE)
    df['seq_list'] = df['sequence'].apply(eval)
    samples = df['seq_list'].sample(N_CAND, random_state=123).tolist()

    # 2) 生成 & 汇编
    bins = []
    for i, seq in enumerate(samples):
        asm = make_asm(seq, i)
        (TMP_DIR/f"cand{i}.s").write_text(asm)
        bins.append(assemble_and_extract(i))

    # 3) 写 candidates.h
    with OUT_CAND_H.open("w") as f:
        f.write("// Auto-generated by gen_candf.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define N_CAND {N_CAND}\n")
        f.write(f"#define N_INST {N_INST}\n\n")
        f.write("static const uint32_t cand_seq[N_CAND][N_INST] = {\n")
        for data in bins:
            words = [
                f"0x{int.from_bytes(data[j*4:(j+1)*4], 'little'):08X}"
                for j in range(N_INST)
            ]
            f.write("  { " + ", ".join(words) + " },\n")
        f.write("};\n")

    # 4) 生成 cand_feat.h
    vectorizer = joblib.load(VECT_FILE)
    FEATURE_DIM = len(vectorizer.get_feature_names_out())

    interpreter = Interpreter(model_path=TFLITE_FILE)
    interpreter.allocate_tensors()
    inp_det = interpreter.get_input_details()[0]
    scale, zero_point = inp_det["quantization"]
    print(f"Using scale={scale}, zero_point={zero_point}")

    lines = [" ".join(seq) for seq in samples]
    X = vectorizer.transform(lines).toarray().astype(np.float32)
    Xq = np.clip(np.round(X/scale + zero_point), -128, 127).astype(np.int8)

    with OUT_FEAT_H.open("w") as f:
        f.write("// Auto-generated by gen_candf.py\n")
        f.write("#pragma once\n\n")
        f.write(f"#define N_CAND      {N_CAND}\n")
        f.write(f"#define FEATURE_DIM {FEATURE_DIM}\n\n")
        f.write("static const int8_t cand_feat[N_CAND][FEATURE_DIM] = {\n")
        for row in Xq:
            f.write("  { " + ", ".join(str(int(v)) for v in row) + " },\n")
        f.write("};\n")

    print("Done:", OUT_CAND_H, OUT_FEAT_H)

if __name__=="__main__":
    main()
